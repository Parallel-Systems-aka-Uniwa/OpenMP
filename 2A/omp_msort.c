/*
 *  === Αρχείο: omp_msort.c ===
 *
 *  Ονοματεπώνυμο: Αθανασίου Βασίλειος Ευάγγελος
 *  Αριθμός Μητρώου: 19390005
 *  Πρόγραμμα Σπουδών: ΠΑΔΑ
 *  
 *  Μεταγλώττιση: gcc -o omp_msort omp_msort.c -fopenmp
 *  Εκτέλεση: ./omp_msort A_unsort.txt A_sort.txt
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <omp.h>

#define T 100
#define N 10000000
#define LIMIT 1000

void multisort(int *start, int *space, int size);
void quicksort(int *start, int *end);
int* pivotPartition(int *start, int *end);
void swap(int *a, int *b);
void merge(int *startA, int *endA, int *startB, int *endB, int *space);

int main(int argc, char *argv[]) 
{
    int *A, *Space;                 // Ο πίνακας Α που θα ταξινομηθεί και ο πίνακας Space που θα χρησιμοποιηθεί για την ταξινόμηση
    FILE *fpA_unsort, *fpA_sort;    // Αρχεία εξόδου για την αποθήκευση των πινάκων Α πριν και μετά την ταξινόμηση
    int threads, size;              // Ο αριθμός των threads και το μέγεθος του πίνακα
    int i;                          // Δείκτης επανάληψης
    double start_time, end_time;    // Χρόνος εκτέλεσης του παράλληλου προγράμματος

/*
 *  Ορισμός του αριθμού των threads και άνοιγμα των αρχείων εξόδου 
 */
    // Επιβεβαιώνουμε ότι οι παράμετροι είναι ακέραιοι
    threads = T;
    size = N;

    omp_set_num_threads(threads);

    if (argc != 3) 
    {
        printf("Usage: %s A_unsort.txt A_sort.txt\n", argv[0]);
        exit(1);
    }

    fpA_unsort = fopen(argv[1], "w");
    if (fpA_unsort == NULL) 
    {
        printf("Cannot open file %s\n", argv[1]);
        exit(1);
    }

    fpA_sort = fopen(argv[2], "w");
    if (fpA_sort == NULL) 
    {
        printf("Cannot open file %s\n", argv[2]);
        exit(1);
    }

    printf("Threads             : %d\n", threads);
    printf("Matrix size         : %d\n", size);
    printf("Limit for quicksort : %d\n", LIMIT);
    printf("-----------------------------------\n");

/*
 *  Δέσμευση μνήμης για τους πίνακες Α και Space
 */
    A = (int *) malloc(size * sizeof(int));
    if (A == NULL)
    {
        printf("Memory allocation failed for A\n");
        exit(1);
    }
    
    Space = (int *) malloc(size * sizeof(int));
    if (Space == NULL)
    {
        printf("Memory allocation failed for Space\n");
        exit(1);
    }

/*
 *  Αρχικοποίηση του πίνακα Α με τυχαίες τιμές
 */
    srand(time(NULL));

    for (i = 0; i < size; i++)
    {
        A[i] = rand() % 199 - 99;                  // Τιμές στο διάστημα [-99, 99]
        A[i] = A[i] >= 0 ? A[i] + 10 : A[i] - 10;  // Τυχαία επιλογή προσήμου
    }
    
    printf("Before sorting\n");
    printf("-----------------------------------\n");
    
    for (i = 0; i < size; i++)
        fprintf(fpA_unsort, "%d ", A[i]);
    printf("\n");

// ================================= Έναρξη παράλληλου υπολογισμού =================================
    // ---- Έναρξη χρόνου μέτρησης του παράλληλου προγράμματος ----
    start_time = omp_get_wtime();

    #pragma omp parallel
    {
        #pragma omp single
        multisort(A, Space, size);
    }

    end_time = omp_get_wtime();
    // ---- Λήξη χρόνου μέτρησης του παράλληλου προγράμματος ----
// ================================= Λήξη παράλληλου υπολογισμού =================================

    printf("-----------------------------------\n");
    printf("After sorting\n");
    printf("-----------------------------------\n");
    
    for (i = 0; i < size; i++)
        fprintf(fpA_sort, "%d ", A[i]);
    printf("\n");

    printf("-----------------------------------\n");
    printf("Multisort finished in %lf sec.\n", end_time - start_time);
    printf("-----------------------------------\n");

    fclose(fpA_unsort);
    fclose(fpA_sort);

    free(A);
    free(Space);
    
    return 0;
}

/*
 * === Συνάρτηση multisort ===
 * Παράμετροι: 
 *    - int *start: Δείκτης στην αρχή του πίνακα που πρέπει να ταξινομηθεί.
 *    - int *space: Δείκτης σε έναν βοηθητικό πίνακα ίδιου μεγέθους με τον αρχικό,
 *                  που χρησιμοποιείται κατά τη συγχώνευση των τμημάτων.
 *    - int size: Το μέγεθος του πίνακα που θα ταξινομηθεί.
 * Επιστρέφει: Τίποτα (void).
 *
 * Περιγραφή:
 * Η συνάρτηση `multisort` υλοποιεί έναν παράλληλο αλγόριθμο ταξινόμησης με χρήση του OpenMP.
 * Ο αλγόριθμος χωρίζει τον πίνακα σε τέσσερα τμήματα (quarters), ταξινομεί κάθε τμήμα 
 * αναδρομικά και στη συνέχεια συγχωνεύει τα ταξινομημένα τμήματα. Όταν το μέγεθος του
 * τμήματος είναι μικρότερο από το όριο `LIMIT`, χρησιμοποιείται αλγόριθμος `quicksort` για
 * την τοπική ταξινόμηση.
 *
 * Βήματα λειτουργίας:
 * 1. Αν το μέγεθος του πίνακα είναι μικρότερο από το `LIMIT`, χρησιμοποιείται η `quicksort`
 *    για την ταξινόμηση και επιστρέφεται.
 * 2. Διαφορετικά, ο πίνακας χωρίζεται σε τέσσερα τμήματα (quarters), το καθένα από τα οποία
 *    αντιμετωπίζεται ως ανεξάρτητο πρόβλημα ταξινόμησης.
 * 3. Με χρήση του OpenMP, κάθε τμήμα ταξινομείται αναδρομικά μέσω της `multisort`.
 * 4. Αφού ολοκληρωθεί η ταξινόμηση των τμημάτων, συγχωνεύονται ανά δύο σε ένα ενδιάμεσο
 *    πίνακα (space), με χρήση της συνάρτησης `merge`.
 * 5. Τέλος, τα δύο ενδιάμεσα αποτελέσματα συγχωνεύονται ξανά στον αρχικό πίνακα.
 *
 * Σημείωση:
 * Η παράλληλη επεξεργασία επιτυγχάνεται με τις OpenMP tasks, οι οποίες εξασφαλίζουν ότι
 * κάθε τμήμα μπορεί να ταξινομηθεί ανεξάρτητα από τα άλλα.
 */
void multisort(int *start, int *space, int size)
{
    int quarter;
    int *startA, *startB, *startC, *startD;
    int *spaceA, *spaceB, *spaceC, *spaceD;

    if (size < LIMIT)
    {
        quicksort(start, start + size - 1);
        return;
    }

    quarter = size / 4;
    startA = start; spaceA = space;
    startB = startA + quarter; spaceB = spaceA + quarter;
    startC = startB + quarter; spaceC = spaceB + quarter;
    startD = startC + quarter; spaceD = spaceC + quarter;

    #pragma omp task firstprivate(start, space, size)
    multisort(startA, spaceA, quarter);

    #pragma omp task firstprivate(start, space, size)
    multisort(startB, spaceB, quarter);

    #pragma omp task firstprivate(start, space, size)
    multisort(startC, spaceC, quarter);

    #pragma omp task firstprivate(start, space, size)
    multisort(startD, spaceD, size - 3 * quarter);

    #pragma omp taskwait

    #pragma omp task firstprivate(start, space, size)
    merge(startA, startA + quarter - 1, startB, startB + quarter - 1, spaceA);

    #pragma omp task firstprivate(start, space, size)
    merge(startC, startC + quarter - 1, startD, start + size - 1, spaceC);

    #pragma omp taskwait

    merge(spaceA, spaceC - 1, spaceC, spaceA + size - 1, startA);
}

/*
 * === Συνάρτηση quicksort ===
 * Παράμετροι: 
 *    - int *start: Δείκτης στην αρχή του τμήματος του πίνακα που πρέπει να ταξινομηθεί.
 *    - int *end: Δείκτης στο τέλος του τμήματος του πίνακα που πρέπει να ταξινομηθεί.
 * Επιστρέφει: Τίποτα (void).
 *
 * Περιγραφή:
 * Η συνάρτηση `quicksort` υλοποιεί τον αναδρομικό αλγόριθμο γρήγορης ταξινόμησης (QuickSort).
 * Ο αλγόριθμος βασίζεται στη διαίρεση και κατάκτηση (divide-and-conquer):
 * 1. Επιλέγει έναν άξονα (pivot) από το τμήμα του πίνακα που ταξινομείται.
 * 2. Τοποθετεί όλα τα στοιχεία μικρότερα ή ίσα με τον άξονα στα αριστερά του
 *    και όλα τα μεγαλύτερα στα δεξιά του, διαχωρίζοντας τον πίνακα σε δύο υποπίνακες.
 * 3. Επαναλαμβάνει αναδρομικά τη διαδικασία για τον αριστερό και δεξιό υποπίνακα
 *    μέχρι να επιτευχθεί η πλήρης ταξινόμηση.
 *
 * Βήματα λειτουργίας:
 * 1. Ελέγχει αν το τμήμα του πίνακα είναι έγκυρο προς ταξινόμηση (δηλ. αν start < end).
 * 2. Καλεί τη συνάρτηση `pivotPartition` για να επιλέξει έναν άξονα και να διαχωρίσει
 *    τα στοιχεία γύρω από αυτόν.
 * 3. Αναδρομικά ταξινομεί τα δύο υποτμήματα:
 *    - Από το `start` έως το στοιχείο πριν από τον άξονα (`pvt - 1`).
 *    - Από το στοιχείο μετά τον άξονα (`pvt + 1`) έως το `end`.
 *
 * Σημείωση:
 * Η συνάρτηση χρησιμοποιεί τη `pivotPartition` για τον διαχωρισμό του πίνακα και τη `swap`
 * για την ανταλλαγή των στοιχείων.
 * Ο αλγόριθμος είναι ιδιαίτερα αποδοτικός, με μέση πολυπλοκότητα O(n log n) και χειρότερη O(n^2).
 */
void quicksort(int *start, int *end)
{
    int *pvt;

    if (start < end)
    {
        pvt = pivotPartition(start, end);
        quicksort(start, pvt - 1);
        quicksort(pvt + 1, end);
    }
}

/*
 * === Συνάρτηση pivotPartition ===
 * Παράμετροι:
 *    - int *start: Δείκτης στην αρχή του τμήματος του πίνακα που πρέπει να διαχωριστεί.
 *    - int *end: Δείκτης στο τέλος του τμήματος του πίνακα που πρέπει να διαχωριστεί.
 * Επιστρέφει: 
 *    - int*: Δείκτης στο νέο σημείο όπου βρίσκεται ο άξονας (pivot) μετά τον διαχωρισμό.
 *
 * Περιγραφή:
 * Η συνάρτηση `pivotPartition` εκτελεί τον διαχωρισμό του πίνακα γύρω από έναν επιλεγμένο άξονα (pivot).
 * 1. Το pivot ορίζεται αρχικά ως το τελευταίο στοιχείο του τμήματος του πίνακα.
 * 2. Μετακινεί όλα τα στοιχεία μικρότερα ή ίσα με το pivot στην αριστερή πλευρά του πίνακα,
 *    ενώ τα μεγαλύτερα παραμένουν στη δεξιά πλευρά.
 * 3. Τέλος, το pivot τοποθετείται στη σωστή του θέση, δηλαδή μεταξύ των μικρότερων και των μεγαλύτερων στοιχείων.
 *
 * Βήματα λειτουργίας:
 * 1. Ο δείκτης `i` αρχικοποιείται μία θέση πριν την αρχή του πίνακα (`start - 1`).
 * 2. Ο δείκτης `j` διατρέχει τα στοιχεία από την αρχή του πίνακα (`start`) έως και το προτελευταίο στοιχείο (`end - 1`).
 * 3. Για κάθε στοιχείο:
 *    - Αν είναι μικρότερο ή ίσο με το pivot, αυξάνεται ο δείκτης `i` και γίνεται ανταλλαγή
 *      (swap) των στοιχείων στους δείκτες `i` και `j`.
 * 4. Τέλος, το pivot ανταλλάσσεται με το στοιχείο ακριβώς μετά το τελευταίο μικρότερο ή ίσο στοιχείο (`i + 1`),
 *    ώστε να τοποθετηθεί στη σωστή του θέση.
 * 5. Επιστρέφεται ο δείκτης της τελικής θέσης του pivot.
 *
 * Σημείωση:
 * Η συνάρτηση χρησιμοποιείται στον αλγόριθμο γρήγορης ταξινόμησης (QuickSort) για τον διαχωρισμό του πίνακα.
 * Απαιτεί τη συνάρτηση `swap` για την ανταλλαγή στοιχείων.
 * Ο διαχωρισμός διαρκεί γραμμικό χρόνο, με πολυπλοκότητα O(n), όπου n είναι το μέγεθος του τμήματος του πίνακα.
 */
int* pivotPartition(int *start, int *end)
{
    int *pvt;
    int *i, *j;

    pvt = end;  
    i = start - 1;  

    for (j = start; j < end; j++)  
    {
        if (*j <= *pvt)  
        {
            i++;
            swap(i, j); 
        }
    }

    swap(i + 1, pvt);  

    return i + 1; 
}

/*
 * === Συνάρτηση swap ===
 * Παράμετροι:
 *    - int *a: Δείκτης στο πρώτο στοιχείο που θα ανταλλαγεί.
 *    - int *b: Δείκτης στο δεύτερο στοιχείο που θα ανταλλαγεί.
 * Επιστρέφει: Τίποτα (void).
 *
 * Περιγραφή:
 * Η συνάρτηση `swap` πραγματοποιεί την ανταλλαγή (swap) των τιμών δύο μεταβλητών 
 * που δείχνονται από τους δείκτες `a` και `b`. 
 *
 * Βήματα λειτουργίας:
 * 1. Η τιμή που δείχνεται από τον δείκτη `a` αποθηκεύεται προσωρινά στη μεταβλητή `temp`.
 * 2. Η τιμή που δείχνεται από τον δείκτη `b` αντιγράφεται στη θέση του `a`.
 * 3. Η τιμή της `temp` (αρχική τιμή του `a`) αντιγράφεται στη θέση του `b`.
 *
 * Σημείωση:
 * Αυτή η λειτουργία χρησιμοποιείται ευρέως σε αλγορίθμους ταξινόμησης, όπως 
 * στη γρήγορη ταξινόμηση (QuickSort), για την αναδιάταξη των στοιχείων στον πίνακα.
 * Η συνάρτηση είναι σταθερού χρόνου, με πολυπλοκότητα O(1).
 */
void swap(int *a, int *b)
{
    int temp;

    temp = *a;
    *a = *b;
    *b = temp;
}


/*
 * === Συνάρτηση merge ===
 * Παράμετροι:
 *    - int *startA: Δείκτης στο πρώτο στοιχείο του πρώτου υποπίνακα (A).
 *    - int *endA: Δείκτης στο τελευταίο στοιχείο του πρώτου υποπίνακα (A).
 *    - int *startB: Δείκτης στο πρώτο στοιχείο του δεύτερου υποπίνακα (B).
 *    - int *endB: Δείκτης στο τελευταίο στοιχείο του δεύτερου υποπίνακα (B).
 *    - int *space: Δείκτης σε προσωρινό χώρο αποθήκευσης (διάμεσος πίνακας).
 * Επιστρέφει: Τίποτα (void).
 *
 * Περιγραφή:
 * Η συνάρτηση `merge` συγχωνεύει δύο ταξινομημένα υποτμήματα (A και B) σε έναν
 * ενιαίο ταξινομημένο πίνακα. Ο συγχωνευμένος πίνακας αποθηκεύεται αρχικά
 * στον προσωρινό πίνακα `space` και στη συνέχεια επιστρέφεται στον αρχικό πίνακα.
 *
 * Βήματα λειτουργίας:
 * 1. Δημιουργεί δείκτες `i` και `j` για την αρχή των υποπινάκων A και B, 
 *    και δείκτη `k` για την αρχή του προσωρινού πίνακα `space`.
 * 2. Συγκρίνει τα στοιχεία των δύο υποπινάκων (A και B) και αποθηκεύει 
 *    το μικρότερο στοιχείο στον πίνακα `space`.
 * 3. Αντιγράφει τυχόν εναπομείναντα στοιχεία από τους υποπίνακες A ή B 
 *    στον πίνακα `space`.
 * 4. Αντιγράφει τα συγχωνευμένα στοιχεία από τον πίνακα `space` πίσω στον
 *    αρχικό πίνακα A.
 *
 * Σημείωση:
 * - Η συνάρτηση αποτελεί βασικό κομμάτι του αλγορίθμου συγχώνευσης 
 *   (MergeSort) και άλλων παραλλαγών ταξινόμησης.
 * - Η πολυπλοκότητα της συγχώνευσης είναι γραμμική O(n), όπου n είναι το
 *   συνολικό μέγεθος των υποπινάκων A και B.
 *
 * Παράδειγμα χρήσης:
 * Υποθέστε δύο ταξινομημένους υποπίνακες:
 *    A = [2, 5, 8]
 *    B = [1, 3, 7]
 * Το αποτέλεσμα της συγχώνευσης θα είναι:
 *    Merged = [1, 2, 3, 5, 7, 8]
 */
void merge(int *startA, int *endA, int *startB, int *endB, int *space)
{
    int *i = startA, *j = startB, *k = space;

    while (i <= endA && j <= endB)
    {
        if (*i <= *j)
        {
            *k = *i;
            i++;
        }
        else
        {
            *k = *j;
            j++;
        }
        k++;
    }

    while (i <= endA)
    {
        *k = *i;
        i++;
        k++;
    }

    while (j <= endB)
    {
        *k = *j;
        j++;
        k++;
    }

    for (i = space; i < k; i++)
    {
        *startA = *i;
        startA++;
    }
}